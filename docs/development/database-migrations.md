# Database Migration Guide

This guide covers database migration procedures for the Tracktion system.

## Overview

Tracktion uses:
- **Alembic** for PostgreSQL schema migrations
- **Python scripts** for Neo4j constraint and index management

## Prerequisites

1. Ensure databases are running:
```bash
docker-compose -f infrastructure/docker-compose.yaml up -d postgres neo4j
```

2. Verify environment variables are set in `.env`:
```bash
DATABASE_URL=postgresql://tracktion:tracktion@localhost:5432/tracktion
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_password
```

## PostgreSQL Migrations with Alembic

### Running Migrations

Apply all pending migrations:
```bash
uv run alembic upgrade head
```

Apply migrations step by step:
```bash
uv run alembic upgrade +1  # Apply next migration
```

Check current migration status:
```bash
uv run alembic current
```

View migration history:
```bash
uv run alembic history
```

### Creating New Migrations

After modifying SQLAlchemy models:

1. Generate migration automatically:
```bash
uv run alembic revision --autogenerate -m "Add new field to Recording model"
```

2. Review the generated migration file in `alembic/versions/`

3. Edit if necessary (autogenerate may miss some changes)

4. Apply the migration:
```bash
uv run alembic upgrade head
```

### Rolling Back Migrations

Rollback last migration:
```bash
uv run alembic downgrade -1
```

Rollback to specific revision:
```bash
uv run alembic downgrade <revision_id>
```

Rollback all migrations:
```bash
uv run alembic downgrade base
```

### Migration Best Practices

1. **Always review autogenerated migrations** - They may miss:
   - Column type changes
   - Table/column renames
   - Custom SQL objects

2. **Test migrations locally first**:
```bash
# Apply migration
uv run alembic upgrade head

# Test functionality
uv run pytest tests/integration/

# Rollback and re-apply to verify
uv run alembic downgrade -1
uv run alembic upgrade head
```

3. **Include both upgrade and downgrade paths** in custom migrations

4. **Use meaningful migration messages**:
   - Good: "Add created_at timestamp to metadata table"
   - Bad: "Update database"

## Neo4j Schema Management

### Initialize Constraints and Indexes

Run the initialization script:
```bash
uv run python scripts/initialize_neo4j.py
```

This creates:
- Uniqueness constraint on Recording.uuid
- Index on Metadata.key for faster lookups

### Manual Neo4j Operations

Connect via Python:
```python
from shared.core_types.src.neo4j_repository import Neo4jRepository
import os

repo = Neo4jRepository(
    uri=os.getenv("NEO4J_URI"),
    user=os.getenv("NEO4J_USER"),
    password=os.getenv("NEO4J_PASSWORD")
)

# Create constraints
repo.create_constraints()

# Clear database (WARNING: deletes all data)
# repo.clear_database()

repo.close()
```

### Neo4j Browser Access

For manual queries and debugging:

1. Open http://localhost:7474
2. Login with credentials from `.env`
3. Useful queries:

```cypher
// Count all nodes
MATCH (n) RETURN count(n)

// View schema
CALL db.schema.visualization()

// Show all constraints
SHOW CONSTRAINTS

// Show all indexes
SHOW INDEXES
```

## Troubleshooting

### Common Issues

#### Migration fails with "relation already exists"

This happens when database state doesn't match migration history.

Solution:
1. Check current state: `uv run alembic current`
2. Manually sync if needed: `uv run alembic stamp head`

#### Cannot connect to database

Check:
1. Docker containers running: `docker ps`
2. Environment variables set: `echo $DATABASE_URL`
3. Network connectivity: `pg_isready -h localhost -p 5432`

#### Neo4j constraint already exists

The initialization script handles existing constraints gracefully. If you see warnings, they can be ignored.

#### Migration creates duplicate index

PostgreSQL and Alembic may have different ideas about index names.

Solution:
1. Drop the index manually
2. Re-run migration
3. Or edit migration to check for existence

### Resetting Databases (Development Only)

Complete reset of PostgreSQL:
```bash
# Stop containers
docker-compose -f infrastructure/docker-compose.yaml down

# Remove volume
docker volume rm infrastructure_postgres_data

# Restart and migrate
docker-compose -f infrastructure/docker-compose.yaml up -d postgres
uv run alembic upgrade head
```

Complete reset of Neo4j:
```bash
# Via Python
uv run python -c "
from shared.core_types.src.neo4j_repository import Neo4jRepository
import os
repo = Neo4jRepository(os.getenv('NEO4J_URI'), os.getenv('NEO4J_USER'), os.getenv('NEO4J_PASSWORD'))
repo.clear_database()
repo.create_constraints()
repo.close()
"
```

## Production Considerations

1. **Always backup before migrations**
2. **Test migrations on staging environment first**
3. **Use migration locks to prevent concurrent migrations**
4. **Monitor migration performance on large datasets**
5. **Plan for rollback scenarios**

## Migration Naming Convention

Use descriptive names following this pattern:
- `001_initial_schema.py` - Initial database setup
- `002_add_bpm_to_metadata.py` - Feature additions
- `003_fix_tracklist_constraint.py` - Bug fixes
- `004_optimize_metadata_index.py` - Performance improvements

## References

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [Neo4j Python Driver](https://neo4j.com/docs/python-manual/current/)
- [SQLAlchemy Migration Patterns](https://docs.sqlalchemy.org/en/latest/core/migrations.html)
