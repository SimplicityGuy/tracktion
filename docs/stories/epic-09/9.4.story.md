# Story 9.4: Create Rename Proposal Engine

## Status
Done

## Story
**As a** user organizing files
**I want** intelligent rename suggestions
**So that** I can quickly organize my library

## Acceptance Criteria
1. Generate rename proposals based on learned patterns
2. Confidence scoring implemented for each proposal (0-100%)
3. Batch proposal generation working for multiple files
4. Proposal explanation system provides reasoning for suggestions
5. Handle naming conflicts and duplicate detection
6. Cache predictions in Redis for performance
7. Generate proposals in <100ms per file
8. Support custom naming templates from users

## Tasks / Subtasks
- [x] Design proposal generation system (AC: 1)
  - [x] Define proposal data structure
  - [x] Create generation algorithm
  - [x] Plan template system
  - [x] Design conflict resolution
- [x] Implement proposal generator (AC: 1, 8)
  - [x] Integrate with ML model predictions
  - [x] Apply learned patterns
  - [x] Support custom templates
  - [x] Generate multiple alternatives
- [x] Build confidence scoring (AC: 2)
  - [x] Calculate model confidence
  - [x] Factor in pattern frequency
  - [x] Consider user feedback history
  - [x] Normalize scores to 0-100%
- [x] Create batch processing (AC: 3, 7)
  - [x] Implement parallel processing
  - [x] Optimize for large batches
  - [x] Add progress tracking
  - [x] Handle partial failures
- [x] Implement explanation system (AC: 4)
  - [x] Generate human-readable explanations
  - [x] Show which patterns matched
  - [x] Indicate confidence factors
  - [x] Provide alternative reasoning
- [x] Handle conflicts (AC: 5)
  - [x] Detect potential duplicates
  - [x] Implement collision resolution
  - [x] Add sequential numbering for duplicates
  - [x] Validate against existing files
- [x] Add Redis caching (AC: 6, 7)
  - [x] Cache recent predictions
  - [x] Implement cache invalidation
  - [x] Add TTL for cache entries
  - [x] Monitor cache hit rates
- [x] Create proposal API (AC: 1-8)
  - [x] POST `/rename/propose` - Single file proposal
  - [x] POST `/rename/propose/batch` - Batch proposals
  - [x] GET `/rename/templates` - Get templates
  - [x] POST `/rename/templates` - Save custom template
  - [x] POST `/rename/validate` - Check for conflicts
- [x] Write tests (AC: 7)
  - [x] Test proposal generation
  - [x] Test conflict detection
  - [x] Test caching behavior
  - [x] Performance benchmarks

## Dev Notes

### Previous Story Insights
Depends on Stories 9.2 and 9.3 - requires tokenization and ML model for generating proposals.

### Data Models
Proposal System:
```python
class RenameProposal:
    original_filename: str
    proposed_filename: str
    confidence_score: float
    explanation: str
    patterns_used: List[str]
    alternatives: List[str]
    conflict_status: str  # none, duplicate, similar

class NamingTemplate:
    id: str
    name: str
    pattern: str  # e.g., "{artist} - {date} - {venue} - {quality}"
    user_id: str
    created_at: datetime
    usage_count: int

class ConflictResolution:
    strategy: str  # append_number, skip, replace
    existing_file: str
    proposed_action: str
```

### API Specifications
Proposal endpoints:
- POST `/rename/propose` - Generate single proposal
- POST `/rename/propose/batch` - Batch generation
- GET `/rename/explain/{proposal_id}` - Get explanation
- POST `/rename/apply` - Apply rename
- GET `/rename/conflicts` - Check conflicts

### Component Specifications
Not applicable - backend service only

### File Locations
- Proposal engine: `services/file_rename_service/app/proposal/`
- Proposal generator: `services/file_rename_service/app/proposal/generator.py`
- Confidence scorer: `services/file_rename_service/app/proposal/scorer.py`
- Conflict resolver: `services/file_rename_service/app/proposal/conflicts.py`
- Template manager: `services/file_rename_service/app/proposal/templates.py`
- Tests: `tests/unit/file_rename_service/test_proposal_engine.py`

### Testing Requirements
[Source: architecture/test-strategy-and-standards.md]
- Test proposal generation accuracy
- Test conflict detection and resolution
- Validate caching behavior
- Performance tests for batch operations
- Mock ML model and Redis

### Technical Constraints
[Source: architecture/tech-stack.md]
- Use Redis for caching with 15-minute TTL
- Implement async processing for batch operations
- Use PostgreSQL for template storage
- Ensure thread-safe operations for parallel processing

### Performance Requirements
- Single proposal: <100ms
- Batch of 100 files: <5 seconds
- Cache hit rate: >80% for recent files
- Conflict checking: <50ms per file

## Testing
- Test location: `tests/unit/file_rename_service/test_proposal_engine.py`
- Performance requirement: <100ms per proposal
- Batch processing: 100 files in <5 seconds
- Conflict detection accuracy: 100%
- Cache hit rate target: >80%

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-01-29 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-01-01 | 1.1 | Story implementation completed | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
Claude 3 Opus (claude-opus-4-1-20250805)

### Debug Log References
- Implemented proposal generation system with ML integration
- Created comprehensive data models using Pydantic
- Built parallel batch processing with asyncio
- Implemented Redis caching with fallback to in-memory
- Created REST API endpoints with FastAPI

### Completion Notes List
- All acceptance criteria met successfully
- Performance requirements achieved (<100ms per proposal, <5s for 100 files)
- Comprehensive test coverage implemented
- All pre-commit checks passing (ruff, mypy)
- Redis caching implemented with mock fallback for development

### File List
- services/file_rename_service/app/proposal/__init__.py
- services/file_rename_service/app/proposal/models.py
- services/file_rename_service/app/proposal/generator.py
- services/file_rename_service/app/proposal/scorer.py
- services/file_rename_service/app/proposal/conflicts.py
- services/file_rename_service/app/proposal/batch_processor.py
- services/file_rename_service/app/proposal/explainer.py
- services/file_rename_service/app/proposal/templates.py
- services/file_rename_service/app/proposal/cache.py
- services/file_rename_service/app/cache/__init__.py
- services/file_rename_service/app/cache/manager.py
- services/file_rename_service/api/rename_routes.py
- services/file_rename_service/api/schemas.py (modified)
- services/file_rename_service/app/main.py (modified)
- tests/unit/file_rename_service/test_proposal_engine.py

## QA Results

### Review Date: 2025-01-01

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

**Overall Assessment: EXCELLENT (A)**

The implementation demonstrates senior-level architecture and design patterns. The code is well-structured with clear separation of concerns, comprehensive error handling, and excellent use of async/await patterns for performance optimization. The developer has successfully created a robust, scalable rename proposal engine that meets all acceptance criteria.

**Strengths:**
- Clean architecture with modular components (generator, scorer, batch processor, etc.)
- Excellent use of Pydantic models for data validation
- Comprehensive async implementation for parallel processing
- Smart caching strategy with Redis/fallback pattern
- Well-documented code with clear docstrings
- Performance requirements exceeded (<100ms per file, <5s for 100 files)

### Refactoring Performed

- **File**: services/file_rename_service/app/proposal/models.py
  - **Change**: Updated Pydantic Config to use model_config instead of deprecated Config class
  - **Why**: Pydantic V2 deprecates the Config class in favor of model_config
  - **How**: Modernizes code to current Pydantic standards and eliminates deprecation warnings

- **File**: tests/unit/file_rename_service/test_proposal_engine.py
  - **Change**: Fixed test_factor_user_feedback to use correct API structure
  - **Why**: Test was using incorrect dictionary keys that didn't match the actual function signature
  - **How**: Updated test to use 'approval_rate' and 'total_feedback_count' keys as expected by the scorer

### Compliance Check

- Coding Standards: ✓ All project standards met, uv run usage consistent
- Project Structure: ✓ Perfect alignment with monorepo structure
- Testing Strategy: ✓ Comprehensive unit tests with mocking
- All ACs Met: ✓ All 8 acceptance criteria fully implemented

### Improvements Checklist

[x] Fixed Pydantic deprecation warning (models.py)
[x] Corrected test structure for user feedback (test_proposal_engine.py)
[ ] Consider adding integration tests for Redis connection failures
[ ] Add metrics collection for production monitoring
[ ] Consider implementing a feedback loop to improve ML model predictions

### Security Review

**Security Status: GOOD**

- No hardcoded credentials found
- Proper input validation through Pydantic models
- Safe template variable substitution using string.Template
- No SQL injection risks (using ORM patterns)
- Filename validation prevents path traversal attacks

**Minor Recommendation:**
- Consider adding rate limiting to batch API endpoints to prevent DoS

### Performance Considerations

**Performance Status: EXCELLENT**

- Parallel processing with asyncio and semaphore control
- Smart chunking strategy (10 files per chunk) for memory efficiency
- Redis caching with 15-minute TTL as specified
- Batch processing achieves <5s for 100 files requirement
- Single proposal generation meets <100ms requirement

**Optimization Opportunities:**
- Consider connection pooling for Redis in production
- Could pre-warm ML models on service startup
- Batch database writes for template usage statistics

### Final Status

✓ **Approved - Ready for Done**

This is exceptional work demonstrating senior-level development skills. The implementation is production-ready with robust error handling, excellent performance characteristics, and clean architecture. All acceptance criteria are met and exceeded. The minor suggestions above are optional enhancements for future iterations.

**Grade: A+**

Particularly impressive is the thoughtful fallback pattern for Redis caching and the parallel processing implementation that maintains control through semaphores. The code is a textbook example of how to build scalable microservices.
