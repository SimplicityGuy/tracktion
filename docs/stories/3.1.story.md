# Story 3.1: Ogg Vorbis File Detection

## Story Information
- **Epic**: 3 - Missing File Format (Ogg Vorbis Support)
- **Story Number**: 3.1
- **Status**: Draft
- **Created**: 2025-08-21
- **Updated**: 2025-08-21

## Story Statement
**As a** DJ with Ogg Vorbis files in my library,
**I want** the system to automatically detect and catalog my .ogg files,
**So that** my entire music collection is properly indexed.

## Acceptance Criteria
1. System detects files with .ogg, .oga extensions
2. File watcher triggers on Ogg Vorbis files
3. Files are added to processing queue
4. Invalid/corrupted files are logged appropriately

## Dev Notes

**Previous Story Insights**:
- Story 2.6 established comprehensive pipeline optimization with monitoring capabilities
- Existing metadata extraction service already uses mutagen library which has OGG support available
- File watcher service structure is in place but needs extension for new formats
- Analysis service has modular format handlers that can be extended
[Source: Story 2.6 Dev Agent Record]

**Technical Stack**:
- **Python**: 3.13 (latest stable)
- **Metadata Library**: mutagen (already in use, supports OGG/Vorbis)
- **Message Queue**: RabbitMQ 4.0 for event-driven communication
- **Logging**: Structured logging with JSON format already implemented
[Source: architecture/tech-stack.md]

**Current File Format Support**:
- Currently supported formats: .mp3, .flac, .wav, .wave, .m4a, .mp4, .m4b, .m4p, .m4v, .m4r
- Metadata extraction implemented in: services/analysis_service/src/metadata_extractor.py
- Format handlers use dictionary mapping: extension → handler function
- SUPPORTED_FORMATS set defined in MetadataExtractor class
[Source: services/analysis_service/src/metadata_extractor.py]

**File Locations**:
- File Watcher Service: services/file_watcher/src/
- Analysis Service metadata: services/analysis_service/src/metadata_extractor.py
- Unit tests: tests/unit/file_watcher/ and tests/unit/analysis_service/
- Integration tests: tests/integration/
[Source: architecture/source-tree.md]

**Message Queue Integration**:
- File watcher publishes file discovery events to RabbitMQ
- Analysis service consumes messages for processing
- Event-driven pattern with correlation IDs for tracing
- Messages should include file path, type, and discovery timestamp
[Source: architecture/high-level-architecture.md]

**Error Handling Requirements**:
- Invalid/corrupted files must be logged with structured logging
- Use correlation IDs for message tracing
- Implement graceful error handling without crashing service
- Log file path, error type, and timestamp for failed files
[Source: architecture/error-handling-strategy.md]

**Testing Requirements**:
- **Framework**: pytest with `uv run pytest` execution
- **Test Location**: tests/unit/file_watcher/ for file detection tests
- **Test Location**: tests/unit/analysis_service/ for metadata extraction tests
- **Coverage Goal**: Minimum 80% for new code
- **Pre-commit**: Must pass all hooks before commit (ruff, mypy, etc.)
[Source: architecture/test-strategy-and-standards.md]

**Library Notes**:
- mutagen library already supports OGG Vorbis through mutagen.oggvorbis module
- No additional dependencies needed for basic OGG support
- pyogg may be needed later for audio decoding in Story 3.3
[Source: Epic 3 technical considerations]

## Tasks / Subtasks

### 1. Update File Watcher to Detect OGG Files (AC: 1, 2)
- [ ] Add .ogg and .oga extensions to file watcher's monitored extensions list
- [ ] Update file detection logic in services/file_watcher/src/main.py
- [ ] Ensure file watcher properly identifies OGG files in scan operations
- [ ] Add logging for OGG file detection events with structured format
- [ ] Write unit tests for OGG file detection in tests/unit/file_watcher/

### 2. Extend Metadata Extractor for OGG Support (AC: 1)
- [ ] Add .ogg and .oga to SUPPORTED_FORMATS in MetadataExtractor class
- [ ] Implement _extract_ogg method using mutagen.oggvorbis
- [ ] Add format handler mapping for .ogg/.oga extensions
- [ ] Handle Vorbis comments extraction (artist, title, album, etc.)
- [ ] Extract technical metadata (bitrate, sample rate, channels, duration)
- [ ] Write unit tests for OGG metadata extraction with sample files

### 3. Update Message Publishing for OGG Files (AC: 3)
- [ ] Ensure file watcher publishes OGG file events to RabbitMQ queue
- [ ] Include proper message format with file type identification
- [ ] Add correlation ID for message tracing
- [ ] Verify message routing to analysis service queue
- [ ] Write integration tests for OGG file message flow

### 4. Implement OGG File Validation (AC: 4)
- [ ] Add OGG file structure validation in metadata extractor
- [ ] Detect and handle corrupted OGG files gracefully
- [ ] Implement proper error logging for invalid files [Source: architecture/error-handling-strategy.md]
- [ ] Return appropriate error codes/messages for different failure types
- [ ] Write unit tests for corrupted file handling scenarios

### 5. Update Cataloging Service Integration (AC: 3)
- [ ] Verify cataloging service handles OGG file metadata correctly
- [ ] Ensure OGG files are stored in PostgreSQL with proper format identification
- [ ] Test that OGG files appear in catalog queries
- [ ] Write integration tests for end-to-end OGG file cataloging

### 6. Documentation and Configuration Updates
- [ ] Update service documentation to include OGG support
- [ ] Add OGG format to supported formats documentation
- [ ] Update configuration examples if needed
- [ ] Add sample OGG files to test data directory
- [ ] Document any OGG-specific considerations or limitations

## Project Structure Notes
This story extends the existing file detection and metadata extraction capabilities to support OGG Vorbis format. The implementation should follow the established patterns in the metadata_extractor.py module, using the existing format handler dictionary approach. No new services or major architectural changes are required - this is an incremental enhancement to existing functionality.

## Testing

### Testing Standards
- **Test Execution**: All tests must use `uv run pytest` (never `pytest` directly)
- **Test Location**:
  - Unit tests for file watcher in `tests/unit/file_watcher/`
  - Unit tests for metadata extraction in `tests/unit/analysis_service/`
- **Test Naming**: Files named `test_*.py`
- **Coverage Goal**: Minimum 80% coverage for new code
- **Pre-commit**: Must pass all hooks before commit
  - Run: `uv run pre-commit run --all-files`
  - Includes: ruff linting, ruff formatting, mypy type checking
- **Task Completion**: Cannot mark task complete until:
  1. Implementation complete
  2. Unit tests written and passing
  3. Pre-commit hooks passing
  4. Code committed with descriptive message

### Story Completion Requirements
1. All tasks marked complete
2. All unit tests passing (`uv run pytest tests/unit/ -v`)
3. Integration tests passing (`uv run pytest tests/integration/ -v`)
4. Pre-commit hooks passing
5. Code coverage ≥80% for new code
6. Story documentation updated
7. All code committed and pushed

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-21 | 1.0 | Initial story creation from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be filled during implementation]

### Debug Log References
[To be filled during implementation]

### Completion Notes
[To be filled during implementation]

### File List
[To be filled during implementation]

## QA Results
[To be filled during QA review]
