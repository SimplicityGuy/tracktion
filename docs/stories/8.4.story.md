# Story 8.4: Async API Endpoints

## Status
Approved

## Story
**As an** API consumer,
**I want** all endpoints to be non-blocking,
**so that** the API can handle many concurrent requests

## Acceptance Criteria
1. All FastAPI endpoints are async
2. WebSocket support for real-time updates
3. Streaming responses where appropriate
4. Request timeout handling
5. Proper error propagation

## Tasks / Subtasks
- [ ] Task 1: Set up FastAPI with async support (AC: 1)
  - [ ] Install FastAPI and uvicorn with async extras
  - [ ] Configure async application startup
  - [ ] Set up async middleware pipeline
  - [ ] Configure CORS for async operations

- [ ] Task 2: Convert all API endpoints to async (AC: 1, 5)
  - [ ] Refactor health check endpoints to async
  - [ ] Convert recording endpoints to async
  - [ ] Update metadata endpoints for async
  - [ ] Refactor tracklist endpoints to async
  - [ ] Convert analysis endpoints to async

- [ ] Task 3: Implement WebSocket support (AC: 2)
  - [ ] Create WebSocket endpoint for progress updates
  - [ ] Implement connection management
  - [ ] Add authentication for WebSocket connections
  - [ ] Create event broadcasting system

- [ ] Task 4: Add streaming response support (AC: 3)
  - [ ] Implement streaming for large file downloads
  - [ ] Add Server-Sent Events for notifications
  - [ ] Create chunked response for batch operations
  - [ ] Implement async generators for data streaming

- [ ] Task 5: Request timeout and cancellation (AC: 4)
  - [ ] Configure request timeout middleware
  - [ ] Implement request cancellation handling
  - [ ] Add timeout configuration per endpoint
  - [ ] Create graceful shutdown for long-running requests

- [ ] Task 6: Error handling and propagation (AC: 5)
  - [ ] Create async error handlers
  - [ ] Implement proper exception middleware
  - [ ] Add request ID tracking for debugging
  - [ ] Ensure error responses are properly formatted

- [ ] Task 7: Rate limiting and backpressure (AC: 1, 4)
  - [ ] Implement async rate limiting
  - [ ] Add backpressure handling
  - [ ] Configure connection limits
  - [ ] Create queue for excess requests

- [ ] Task 8: API documentation and testing (AC: All)
  - [ ] Update OpenAPI schema for async endpoints
  - [ ] Create async integration tests
  - [ ] Test WebSocket connections
  - [ ] Benchmark concurrent request handling
  - [ ] Ensure 80% code coverage

## Dev Notes

### Relevant Architecture Context

#### API Structure
[Source: Architecture context and service structure]
The API layer will be implemented across services:
- Each service will expose its own API endpoints
- Services communicate via RabbitMQ, not direct HTTP
- API gateway pattern for external access

#### Tech Stack
[Source: architecture/tech-stack.md]
- Python 3.13 with async/await
- FastAPI for API framework (implicit from async requirements)
- Uvicorn for ASGI server
- Docker for containerization

#### Project Structure
[Source: architecture/source-tree.md]
API endpoints will be in each service:
- `services/file_watcher/src/api/`
- `services/cataloging_service/src/api/`
- `services/analysis_service/src/api/`
- `services/tracklist_service/src/api/`

#### Async Framework Requirements
[Source: Epic 7 PRD]
- FastAPI with async def endpoints
- Uvicorn ASGI server
- WebSocket support for real-time
- Streaming responses for large data
- Proper timeout handling

#### Performance Targets
[Source: Epic 7 PRD]
- Handle >1000 concurrent requests
- Response time <100ms for 95th percentile
- WebSocket connections >500 concurrent
- Request timeout: 30s default
- Streaming chunk size: 8KB

### Critical Implementation Details

#### FastAPI Async Configuration
```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # Handle WebSocket connection
```

#### Streaming Response Pattern
- Use async generators for data streaming
- Chunk size optimization for network efficiency
- Proper cleanup in finally blocks
- Support for partial content requests

#### WebSocket Architecture
- Connection pool management
- Event-driven message broadcasting
- Heartbeat/ping-pong for connection health
- Graceful reconnection handling

#### Error Handling Strategy
- Global exception handlers
- Request ID in all responses
- Structured error responses
- Proper HTTP status codes

### Testing Requirements
[Source: architecture/test-strategy-and-standards.md]
- Test files in `tests/unit/*/api/`
- Use `uv run pytest` for execution
- Test with httpx for async clients
- WebSocket testing with pytest-asyncio
- Load testing for concurrent requests
- Minimum 80% code coverage

### Coding Standards
[Source: architecture/coding-standards.md]
- Use `uv run` for all Python commands
- Type hints for all async functions
- Proper async context managers
- Environment variables for config
- No direct service-to-service HTTP calls

### API Design Principles
- RESTful resource naming
- Consistent error response format
- Version in URL path (/v1/)
- Pagination for list endpoints
- Rate limiting headers

### Security Considerations
- Authentication middleware (future)
- CORS configuration
- Request validation
- Input sanitization
- Rate limiting per client

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-28 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)
