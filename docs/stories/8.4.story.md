# Story 8.4: Async API Endpoints

## Status
Approved

## Story
**As an** API consumer,
**I want** all endpoints to be non-blocking,
**so that** the API can handle many concurrent requests

## Acceptance Criteria
1. All FastAPI endpoints are async
2. WebSocket support for real-time updates
3. Streaming responses where appropriate
4. Request timeout handling
5. Proper error propagation

## Tasks / Subtasks
- [x] Task 1: Set up FastAPI with async support (AC: 1)
  - [x] Install FastAPI and uvicorn with async extras
  - [x] Configure async application startup
  - [x] Set up async middleware pipeline
  - [x] Configure CORS for async operations

- [x] Task 2: Convert all API endpoints to async (AC: 1, 5)
  - [x] Refactor health check endpoints to async
  - [x] Convert recording endpoints to async
  - [x] Update metadata endpoints for async
  - [x] Refactor tracklist endpoints to async
  - [x] Convert analysis endpoints to async

- [x] Task 3: Implement WebSocket support (AC: 2)
  - [x] Create WebSocket endpoint for progress updates
  - [x] Implement connection management
  - [ ] Add authentication for WebSocket connections (deferred - future story)
  - [x] Create event broadcasting system

- [x] Task 4: Add streaming response support (AC: 3)
  - [x] Implement streaming for large file downloads
  - [x] Add Server-Sent Events for notifications
  - [x] Create chunked response for batch operations
  - [x] Implement async generators for data streaming

- [x] Task 5: Request timeout and cancellation (AC: 4)
  - [x] Configure request timeout middleware
  - [x] Implement request cancellation handling
  - [x] Add timeout configuration per endpoint
  - [x] Create graceful shutdown for long-running requests

- [x] Task 6: Error handling and propagation (AC: 5)
  - [x] Create async error handlers
  - [x] Implement proper exception middleware
  - [x] Add request ID tracking for debugging
  - [x] Ensure error responses are properly formatted

- [ ] Task 7: Rate limiting and backpressure (AC: 1, 4)
  - [ ] Implement async rate limiting
  - [ ] Add backpressure handling
  - [ ] Configure connection limits
  - [ ] Create queue for excess requests

- [ ] Task 8: API documentation and testing (AC: All)
  - [ ] Update OpenAPI schema for async endpoints
  - [ ] Create async integration tests
  - [ ] Test WebSocket connections
  - [ ] Benchmark concurrent request handling
  - [ ] Ensure 80% code coverage

## Dev Notes

### Relevant Architecture Context

#### API Structure
[Source: Architecture context and service structure]
The API layer will be implemented across services:
- Each service will expose its own API endpoints
- Services communicate via RabbitMQ, not direct HTTP
- API gateway pattern for external access

#### Tech Stack
[Source: architecture/tech-stack.md]
- Python 3.13 with async/await
- FastAPI for API framework (implicit from async requirements)
- Uvicorn for ASGI server
- Docker for containerization

#### Project Structure
[Source: architecture/source-tree.md]
API endpoints will be in each service:
- `services/file_watcher/src/api/`
- `services/cataloging_service/src/api/`
- `services/analysis_service/src/api/`
- `services/tracklist_service/src/api/`

#### Async Framework Requirements
[Source: Epic 7 PRD]
- FastAPI with async def endpoints
- Uvicorn ASGI server
- WebSocket support for real-time
- Streaming responses for large data
- Proper timeout handling

#### Performance Targets
[Source: Epic 7 PRD]
- Handle >1000 concurrent requests
- Response time <100ms for 95th percentile
- WebSocket connections >500 concurrent
- Request timeout: 30s default
- Streaming chunk size: 8KB

### Critical Implementation Details

#### FastAPI Async Configuration
```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # Handle WebSocket connection
```

#### Streaming Response Pattern
- Use async generators for data streaming
- Chunk size optimization for network efficiency
- Proper cleanup in finally blocks
- Support for partial content requests

#### WebSocket Architecture
- Connection pool management
- Event-driven message broadcasting
- Heartbeat/ping-pong for connection health
- Graceful reconnection handling

#### Error Handling Strategy
- Global exception handlers
- Request ID in all responses
- Structured error responses
- Proper HTTP status codes

### Testing Requirements
[Source: architecture/test-strategy-and-standards.md]
- Test files in `tests/unit/*/api/`
- Use `uv run pytest` for execution
- Test with httpx for async clients
- WebSocket testing with pytest-asyncio
- Load testing for concurrent requests
- Minimum 80% code coverage

### Coding Standards
[Source: architecture/coding-standards.md]
- Use `uv run` for all Python commands
- Type hints for all async functions
- Proper async context managers
- Environment variables for config
- No direct service-to-service HTTP calls

### API Design Principles
- RESTful resource naming
- Consistent error response format
- Version in URL path (/v1/)
- Pagination for list endpoints
- Rate limiting headers

### Security Considerations
- Authentication middleware (future)
- CORS configuration
- Request validation
- Input sanitization
- Rate limiting per client

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-28 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
- Successfully set up FastAPI with async support including middleware pipeline and CORS
- Implemented all async API endpoints (health, recordings, metadata, tracklist, analysis)
- Created WebSocket support with connection management and event broadcasting
- All tests passing for async endpoints and WebSocket functionality

### Completion Notes List
- Task 1: FastAPI async setup completed with middleware pipeline (Request ID, Timing, Error Handling)
- Task 2: All API endpoints converted to async with proper type hints and error handling
- Task 3: WebSocket implementation complete with subscription management and broadcasting
- Task 4: Streaming support added - audio streaming, SSE events, NDJSON batch processing, log streaming
- Task 5: Request timeout and cancellation implemented with configurable per-endpoint timeouts
- Task 6: Comprehensive error handling with custom exceptions and structured error responses
- Note: WebSocket authentication deferred to future story as it requires auth infrastructure
- Tasks 7-8: Not completed due to time constraints

### File List
**Created:**
- services/analysis_service/src/api/__init__.py
- services/analysis_service/src/api/app.py
- services/analysis_service/src/api/middleware.py
- services/analysis_service/src/api/websocket.py
- services/analysis_service/src/api/timeout.py
- services/analysis_service/src/api/errors.py
- services/analysis_service/src/api/endpoints/__init__.py
- services/analysis_service/src/api/endpoints/health.py
- services/analysis_service/src/api/endpoints/recordings.py
- services/analysis_service/src/api/endpoints/metadata.py
- services/analysis_service/src/api/endpoints/tracklist.py
- services/analysis_service/src/api/endpoints/analysis.py
- services/analysis_service/src/api/endpoints/websocket.py
- services/analysis_service/src/api/endpoints/streaming.py
- tests/unit/analysis_service/api/test_app.py
- tests/unit/analysis_service/api/test_endpoints.py
- tests/unit/analysis_service/api/test_websocket.py
- tests/unit/analysis_service/api/test_streaming.py

**Modified:**
- pyproject.toml (added websockets and sse-starlette dependencies)
- services/analysis_service/src/structured_logging.py (added get_logger function)

## QA Results
(To be filled by QA Agent)
