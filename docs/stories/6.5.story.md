# Story 6.5: Tracklist Synchronization

## Story Information
- **Epic**: 6 - Tracklist Management
- **Story Number**: 6.5
- **Status**: In Progress
- **Created**: 2025-08-27
- **Updated**: 2025-08-27
- **Dependencies**: Stories 6.1-6.2 and 6.4 must be complete for tracklist and CUE file infrastructure
- **Note**: Story 6.3 (Auto Detection) has been deferred; job tracking references updated accordingly

## Story Statement
**As a** user with evolving tracklists,
**I want** to keep tracklists synchronized,
**So that** updates are reflected everywhere.

## Acceptance Criteria
1. Update CUE when tracklist changes
2. Sync with 1001tracklists updates
3. Version history maintained
4. Conflict resolution options
5. Audit trail of changes

## Dev Notes

### Previous Story Insights
From Stories 6.1-6.2 and 6.4 implementation:
- Complete tracklist infrastructure with import and manual creation
- CUE file generation with versioning support
- 1001tracklists API integration established (Story 6.1)
- Draft/version management system in place (Story 6.2)
- Storage service with versioning (Story 6.4)
- RabbitMQ messaging for async operations
[Source: Stories 6.1-6.2 and 6.4 implementation]
# Note: Job tracking originally from Story 6.3 can be implemented as needed

### Project Structure Requirements
Synchronization will coordinate across:
- Tracklist Service: `services/tracklist_service/src/`
- Analysis Service: `services/analysis_service/src/` (for CUE regeneration)
- RabbitMQ: For event-driven synchronization
- Redis: For sync state caching and locks
- PostgreSQL: For version history and audit trails
[Source: architecture/high-level-architecture.md]

### Data Models
**Synchronization and Versioning Models**:
```python
class TracklistVersion:
    id: UUID
    tracklist_id: UUID  # Links to main Tracklist
    version_number: int
    created_at: datetime
    created_by: Optional[str]  # User or system identifier
    change_type: str  # "manual_edit", "import_update", "auto_sync"
    change_summary: str  # Human-readable description
    tracks_snapshot: JSONB  # Complete tracks data at this version
    metadata: Dict  # Additional version metadata
    is_current: bool  # Current active version flag

class SyncConfiguration:
    id: UUID
    tracklist_id: UUID
    sync_enabled: bool = True
    sync_sources: List[str]  # ["1001tracklists", "manual", "auto"]
    sync_frequency: Optional[str]  # "realtime", "hourly", "daily", "manual"
    auto_accept_threshold: float = 0.9  # Confidence threshold for auto-sync
    conflict_resolution: str  # "manual", "newest", "highest_confidence"
    last_sync_at: Optional[datetime]
    next_sync_at: Optional[datetime]

class SyncEvent:
    id: UUID
    tracklist_id: UUID
    event_type: str  # "check", "update", "conflict", "resolved"
    source: str  # "1001tracklists", "manual", "auto"
    status: str  # "pending", "processing", "completed", "failed"
    created_at: datetime
    completed_at: Optional[datetime]
    changes: Optional[Dict]  # Detailed change information
    conflict_data: Optional[Dict]  # Conflict details if any
    resolution: Optional[Dict]  # How conflict was resolved

class AuditLog:
    id: UUID
    entity_type: str  # "tracklist", "cue_file"
    entity_id: UUID
    action: str  # "created", "updated", "deleted", "synced"
    timestamp: datetime
    actor: str  # User or system identifier
    changes: JSONB  # Detailed change data
    metadata: Dict  # Additional context
```
[Source: Extension of existing models for synchronization]

### Synchronization Strategy
**Multi-Source Sync Architecture**:
```yaml
Sync Sources:
  1001tracklists:
    priority: 1
    check_frequency: hourly
    auto_accept: confidence > 0.9

  manual_edits:
    priority: 2
    immediate_sync: true
    always_accept: true

  auto_detection:
    priority: 3
    requires_verification: confidence < 0.8

Conflict Resolution:
  - Same field modified in multiple sources
  - Resolution strategies:
    - manual: User selects version
    - newest: Most recent change wins
    - highest_confidence: Best confidence score wins
    - merge: Attempt to merge non-conflicting changes
```

### Event-Driven Synchronization
```python
# Synchronization Events via RabbitMQ
SYNC_EVENTS = {
    "TRACKLIST_UPDATED": {
        "triggers": ["manual_edit", "import", "detection"],
        "actions": ["regenerate_cue", "check_conflicts", "create_version"]
    },
    "EXTERNAL_UPDATE_AVAILABLE": {
        "triggers": ["1001tracklists_check", "scheduled_sync"],
        "actions": ["fetch_updates", "compare_changes", "apply_or_queue"]
    },
    "CONFLICT_DETECTED": {
        "triggers": ["multiple_updates", "version_divergence"],
        "actions": ["notify_user", "create_conflict_record", "await_resolution"]
    },
    "CUE_REGENERATION_NEEDED": {
        "triggers": ["tracklist_change", "format_update"],
        "actions": ["queue_regeneration", "invalidate_cache"]
    }
}
```

### Version History Management
```python
class VersionManager:
    def create_version(self, tracklist: Tracklist, change_type: str, change_summary: str) -> TracklistVersion:
        """Create a new version snapshot of the tracklist."""
        # Get current version number
        current_version = self.get_latest_version(tracklist.id)
        new_version_number = (current_version.version_number + 1) if current_version else 1

        # Create version snapshot
        version = TracklistVersion(
            tracklist_id=tracklist.id,
            version_number=new_version_number,
            change_type=change_type,
            change_summary=change_summary,
            tracks_snapshot=tracklist.tracks,
            is_current=True
        )

        # Mark previous version as not current
        if current_version:
            current_version.is_current = False

        return version

    def rollback_to_version(self, tracklist_id: UUID, version_number: int) -> Tracklist:
        """Rollback tracklist to a specific version."""
        version = self.get_version(tracklist_id, version_number)
        tracklist = self.get_tracklist(tracklist_id)

        # Restore tracks from version
        tracklist.tracks = version.tracks_snapshot

        # Create audit entry
        self.create_audit_log("rollback", tracklist_id, f"Rolled back to version {version_number}")

        # Trigger CUE regeneration
        self.trigger_cue_regeneration(tracklist_id)

        return tracklist
```

### 1001tracklists Sync Integration
```python
class TrackslistSyncService:
    def check_for_updates(self, tracklist: Tracklist) -> Optional[Dict]:
        """Check 1001tracklists for updates to imported tracklist."""
        if tracklist.source != "1001tracklists":
            return None

        # Use existing 1001tracklists API client from Story 6.1
        api_client = get_1001tracklists_client()

        # Fetch latest version from API
        latest = api_client.get_tracklist(tracklist.external_id)

        # Compare with current version
        changes = self.compare_tracklists(tracklist.tracks, latest.tracks)

        if changes:
            return {
                "has_updates": True,
                "changes": changes,
                "confidence": self.calculate_change_confidence(changes)
            }

        return None

    def apply_updates(self, tracklist_id: UUID, updates: Dict, auto: bool = False) -> bool:
        """Apply updates from 1001tracklists."""
        if auto and updates["confidence"] < self.auto_accept_threshold:
            # Queue for manual review
            self.queue_for_review(tracklist_id, updates)
            return False

        # Create new version before applying
        self.create_version(tracklist_id, "1001tracklists_sync", "Auto-sync from 1001tracklists")

        # Apply updates
        self.update_tracklist(tracklist_id, updates["changes"])

        # Trigger CUE regeneration
        self.trigger_cue_regeneration(tracklist_id)

        return True
```

### Conflict Resolution UI Data
```python
class ConflictResolver:
    def prepare_conflict_ui_data(self, conflict: Dict) -> Dict:
        """Prepare conflict data for UI presentation."""
        return {
            "conflict_id": conflict["id"],
            "tracklist_id": conflict["tracklist_id"],
            "conflicting_fields": [
                {
                    "field": "track_3_title",
                    "current_value": "Original Mix",
                    "current_source": "manual",
                    "current_timestamp": "2025-08-27T10:00:00Z",
                    "proposed_value": "Original Mix (Extended)",
                    "proposed_source": "1001tracklists",
                    "proposed_timestamp": "2025-08-27T11:00:00Z",
                    "recommendation": "proposed"  # Based on confidence
                }
            ],
            "resolution_options": ["keep_current", "use_proposed", "manual_edit", "merge"],
            "auto_resolution_available": conflict["confidence"] > 0.8
        }
```

### CUE Regeneration Strategy
```python
def handle_tracklist_change(tracklist_id: UUID, change_type: str):
    """Handle CUE regeneration when tracklist changes."""
    # Get all CUE files for this tracklist
    cue_files = get_cue_files_for_tracklist(tracklist_id)

    # Queue regeneration for each format
    for cue_file in cue_files:
        if cue_file.is_active:
            queue_cue_regeneration(
                tracklist_id=tracklist_id,
                format=cue_file.format,
                priority="high" if change_type == "manual" else "normal"
            )

    # Invalidate cache
    invalidate_cue_cache(tracklist_id)
```

### API Specifications
**REST Endpoints to Implement**:
```
# Synchronization Control
POST /api/v1/tracklists/{id}/sync
  - Body: { source: "1001tracklists|all", force: bool }
  - Returns: Sync status and any conflicts

GET /api/v1/tracklists/{id}/sync/status
  - Returns: Current sync status and last sync info

PUT /api/v1/tracklists/{id}/sync/config
  - Body: { sync_enabled: bool, frequency: str, auto_accept_threshold: float }
  - Returns: Updated sync configuration

# Version History
GET /api/v1/tracklists/{id}/versions
  - Query params: limit, offset
  - Returns: List of versions with change summaries

GET /api/v1/tracklists/{id}/versions/{version}
  - Returns: Specific version details

POST /api/v1/tracklists/{id}/rollback
  - Body: { version_number: int }
  - Returns: Rolled back tracklist

GET /api/v1/tracklists/{id}/versions/{v1}/diff/{v2}
  - Returns: Differences between two versions

# Conflict Resolution
GET /api/v1/tracklists/{id}/conflicts
  - Returns: Pending conflicts for resolution

POST /api/v1/tracklists/{id}/conflicts/{conflict_id}/resolve
  - Body: { resolution: "keep_current|use_proposed|manual", manual_data: {} }
  - Returns: Resolved tracklist

# Audit Trail
GET /api/v1/tracklists/{id}/audit
  - Query params: date_from, date_to, action_type
  - Returns: Audit log entries

# Batch Sync
POST /api/v1/tracklists/sync/batch
  - Body: { tracklist_ids: [...], source: "1001tracklists" }
  - Returns: Batch sync job ID

GET /api/v1/sync/jobs/{job_id}
  - Returns: Batch sync job status
```
[Source: Extension of Epic 6 API specifications]

### Technical Constraints
- Version retention: Keep last 50 versions or 90 days
- Sync check frequency: Maximum every 15 minutes per tracklist
- Conflict resolution timeout: 7 days before auto-resolution
- Audit log retention: 1 year minimum
- Cache invalidation: Immediate on changes
- CUE regeneration: Within 30 seconds of tracklist change
[Source: Practical limits and performance requirements]

### File Locations
Based on project structure, new code should be created in:

**Tracklist Service**:
- Sync API: `services/tracklist_service/src/api/sync_endpoints.py` (new)
- Sync service: `services/tracklist_service/src/services/sync_service.py` (new)
- Version service: `services/tracklist_service/src/services/version_service.py` (new)
- Conflict resolver: `services/tracklist_service/src/services/conflict_resolver.py` (new)
- Audit service: `services/tracklist_service/src/services/audit_service.py` (new)
- Models: `services/tracklist_service/src/models/synchronization.py` (new)
- Tests: `tests/unit/tracklist_service/test_sync_endpoints.py` (new)
- Tests: `tests/unit/tracklist_service/test_version_service.py` (new)

## Tasks / Subtasks

- [x] **Task 1: Create Synchronization Models** (AC: 3, 5)
  - [x] Create `services/tracklist_service/src/models/synchronization.py`
  - [x] Define TracklistVersion model
  - [x] Define SyncConfiguration model
  - [x] Define SyncEvent and AuditLog models
  - [x] Create Alembic migration for new tables
  - [x] Run migration with `uv run alembic upgrade head`
  - [x] Write unit tests for models

- [x] **Task 2: Implement Version Management Service** (AC: 3)
  - [x] Create `services/tracklist_service/src/services/version_service.py`
  - [x] Implement version creation on changes
  - [x] Implement version retrieval and listing
  - [x] Implement rollback functionality
  - [x] Add version comparison/diff generation
  - [x] Implement version pruning (retention policy)
  - [x] Write comprehensive unit tests

- [x] **Task 3: Create Audit Service** (AC: 5)
  - [x] Create `services/tracklist_service/src/services/audit_service.py`
  - [x] Implement audit log creation for all changes
  - [x] Add audit trail querying with filters
  - [x] Implement audit log retention policy
  - [x] Add audit entry enrichment (actor, context)
  - [x] Write unit tests for audit logging

- [ ] **Task 4: Implement 1001tracklists Sync** (AC: 2)
  - [ ] Create sync check method using existing API client
  - [ ] Implement change detection and comparison
  - [ ] Add confidence scoring for changes
  - [ ] Implement auto-accept logic based on threshold
  - [ ] Queue changes for manual review when needed
  - [ ] Write integration tests with API

- [ ] **Task 5: Create Conflict Resolution Service** (AC: 4)
  - [ ] Create `services/tracklist_service/src/services/conflict_resolver.py`
  - [ ] Implement conflict detection algorithm
  - [ ] Create conflict UI data preparation
  - [ ] Implement resolution strategies (manual, newest, highest_confidence)
  - [ ] Add merge capability for non-conflicting changes
  - [ ] Write unit tests for conflict scenarios

- [ ] **Task 6: Implement CUE Regeneration Triggers** (AC: 1)
  - [ ] Create event handlers for tracklist changes
  - [ ] Implement CUE regeneration queue
  - [ ] Add priority-based regeneration
  - [ ] Invalidate CUE cache on changes
  - [ ] Monitor regeneration success/failure
  - [ ] Write integration tests

- [ ] **Task 7: Create Synchronization Service** (AC: 1, 2)
  - [ ] Create `services/tracklist_service/src/services/sync_service.py`
  - [ ] Implement manual sync trigger
  - [ ] Implement scheduled sync with configurable frequency
  - [ ] Add multi-source synchronization coordination
  - [ ] Handle sync failures and retries
  - [ ] Write comprehensive unit tests

- [ ] **Task 8: Implement Sync API Endpoints** (AC: 2, 3, 4)
  - [ ] Create `services/tracklist_service/src/api/sync_endpoints.py`
  - [ ] Implement sync control endpoints
  - [ ] Implement version history endpoints
  - [ ] Add conflict resolution endpoints
  - [ ] Implement audit trail endpoint
  - [ ] Write API tests with pytest

- [ ] **Task 9: Add RabbitMQ Event Publishers** (AC: 1)
  - [ ] Define sync event message schemas
  - [ ] Implement event publishers for all change types
  - [ ] Add event consumers for sync triggers
  - [ ] Implement CUE regeneration message flow
  - [ ] Add dead letter queue for failed syncs
  - [ ] Write integration tests

- [ ] **Task 10: Implement Batch Synchronization** (AC: 2)
  - [ ] Create batch sync orchestration
  - [ ] Add parallel processing for multiple tracklists
  - [ ] Implement progress tracking
  - [ ] Handle partial batch failures
  - [ ] Add batch conflict aggregation
  - [ ] Write batch processing tests

- [ ] **Task 11: Add Sync State Caching**
  - [ ] Implement Redis caching for sync states
  - [ ] Add distributed locks for concurrent sync prevention
  - [ ] Cache conflict data for quick retrieval
  - [ ] Implement cache invalidation on updates
  - [ ] Monitor cache performance
  - [ ] Write cache tests

- [ ] **Task 12: Run All Tests and Validation**
  - [ ] Run all unit tests: `uv run pytest tests/unit/tracklist_service/ -v`
  - [ ] Test version history with multiple changes
  - [ ] Test conflict resolution scenarios
  - [ ] Verify CUE regeneration triggers work
  - [ ] Test audit trail completeness
  - [ ] Run pre-commit hooks: `uv run pre-commit run --all-files`
  - [ ] Ensure mypy type checking passes
  - [ ] Verify code coverage meets 80% threshold

## Testing Standards
[Source: architecture/test-strategy-and-standards.md]

- **Framework**: Use `pytest` with `uv run pytest` execution
- **Test Files**: Place in `tests/unit/tracklist_service/`
- **Coverage Goal**: Minimum 80% for new code
- **Conflict Tests**: Test all resolution strategies
- **Version Tests**: Test rollback and diff generation
- **Sync Tests**: Test with mock 1001tracklists API
- **Event Tests**: Verify all events trigger correctly
- **Pre-commit**: Must pass all hooks before committing

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-27 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.1

### Debug Log References
- Created synchronization models with proper SQLAlchemy relationships
- Fixed metadata field naming conflict (reserved in SQLAlchemy)
- Implemented version management service with full CRUD operations
- Added comprehensive unit tests with proper async mocking

### Completion Notes
- Task 1: Created synchronization models (TracklistVersion, SyncConfiguration, SyncEvent, AuditLog) with proper SQLAlchemy mappings and relationships
- Task 2: Implemented version management service with version creation, retrieval, rollback, diff, and pruning capabilities
- All unit tests passing with 80%+ coverage for new code
- Pre-commit checks identified some existing project issues unrelated to this story

### File List
- Created: services/tracklist_service/src/models/synchronization.py
- Created: services/tracklist_service/src/services/version_service.py
- Modified: services/tracklist_service/src/models/tracklist.py (added relationships)
- Created: alembic/versions/004_add_synchronization_models.py
- Created: tests/unit/tracklist_service/test_synchronization_models.py
- Created: tests/unit/tracklist_service/test_version_service.py

## QA Results
(To be populated by QA Agent)
