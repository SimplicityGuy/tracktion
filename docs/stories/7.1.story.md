# Story 7.1: Async File Watching

## Status
Draft

## Story
**As a** system processing many files,
**I want** file watching to handle thousands of files concurrently,
**so that** large library imports don't block the system

## Acceptance Criteria
1. File watcher uses async I/O operations
2. Concurrent processing of multiple file events
3. Non-blocking metadata extraction
4. Queue operations are asynchronous
5. System remains responsive during bulk operations

## Tasks / Subtasks
- [ ] Task 1: Set up async testing framework for file_watcher service (AC: 1)
  - [ ] Install pytest-asyncio in file_watcher service
  - [ ] Configure test environment for async tests
  - [ ] Create base test fixtures for async operations
  - [ ] Update pyproject.toml with async test dependencies

- [ ] Task 2: Convert file system operations to async (AC: 1, 2)
  - [ ] Replace synchronous file I/O with aiofiles
  - [ ] Implement async file path traversal
  - [ ] Create async file event handler
  - [ ] Update file watching loop to use asyncio

- [ ] Task 3: Implement concurrent file event processing (AC: 2, 5)
  - [ ] Create asyncio task pool for file events
  - [ ] Implement semaphore for resource limiting (max 100 concurrent)
  - [ ] Add task scheduling for file processing
  - [ ] Implement proper error handling for concurrent tasks

- [ ] Task 4: Convert metadata extraction to async (AC: 3)
  - [ ] Refactor metadata extraction functions to async
  - [ ] Use thread pool executor for CPU-bound operations
  - [ ] Implement async caching for metadata results
  - [ ] Add progress tracking for bulk operations

- [ ] Task 5: Update RabbitMQ operations to async (AC: 4)
  - [ ] Install aio-pika for async RabbitMQ
  - [ ] Convert queue publisher to async
  - [ ] Implement async connection management
  - [ ] Add connection pooling for queue operations

- [ ] Task 6: Performance testing and optimization (AC: 5)
  - [ ] Create performance benchmarks for file operations
  - [ ] Test with 1000+ concurrent file events
  - [ ] Measure response time during bulk operations
  - [ ] Optimize resource usage and concurrency limits

- [ ] Task 7: Update unit and integration tests (AC: All)
  - [ ] Convert existing tests to async where needed
  - [ ] Add tests for concurrent file processing
  - [ ] Test edge cases (file permissions, large files)
  - [ ] Ensure 80% code coverage minimum

## Dev Notes

### Relevant Architecture Context

#### Tech Stack
[Source: architecture/tech-stack.md]
- Python 3.13 (latest stable version)
- RabbitMQ 4.0 for message queue system
- Redis 7.4 for caching service
- Docker (latest) for containerization
- uv and ruff for dependency management and linting

#### Project Structure
[Source: architecture/source-tree.md]
The file_watcher service is located at:
- `services/file_watcher/` - Main service directory
- `services/file_watcher/src/` - Source code
- `services/file_watcher/pyproject.toml` - Dependencies
- `services/file_watcher/Dockerfile` - Container configuration
- `tests/unit/file_watcher/` - Unit tests location

#### Async Libraries to Implement
[Source: Epic 7 PRD]
- **aiofiles**: For async file I/O operations
- **aio-pika**: For async RabbitMQ operations
- **asyncio**: Core async/await functionality
- **pytest-asyncio**: For async testing

#### Performance Targets
[Source: Epic 7 PRD]
- Handle >100 concurrent file operations
- Response time <100ms for 95th percentile
- Support for thousands of files without blocking
- Connection pool of 20-50 for external services

#### Critical Implementation Details
- Use semaphores to limit concurrent operations (max 100)
- Implement proper cleanup handlers for async resources
- Use asyncio.gather() for parallel operations
- Thread pool executor for CPU-bound metadata extraction
- Proper error propagation in async context

### Testing Requirements
[Source: architecture/test-strategy-and-standards.md]
- Test files must be named `test_*.py`
- Located in `tests/unit/file_watcher/`
- Must use `uv run pytest` for test execution
- Minimum 80% code coverage for new code
- All tests must pass before story completion
- Use pytest-asyncio for async test support
- Pre-commit hooks must pass: ruff, mypy, formatting

### Coding Standards
[Source: architecture/coding-standards.md]
- Always use `uv run` for Python execution
- Never use plain `python` or `pip` commands
- Maximum line length: 120 characters
- All async functions must have proper type hints
- Use latest stable versions of dependencies
- Configuration from environment variables only
- Inter-service communication via RabbitMQ only

### Migration Strategy Notes
[Source: Epic 7 PRD]
- Maintain compatibility layer during transition
- Parallel testing of sync/async versions
- Feature flags for rollback capability
- Benchmark before and after implementation
- Incremental refactoring approach

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-28 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)
