"""CUE format variants and their specific requirements."""

from .generator import CueDisc, CueFormat, CueGenerator, CueTrack


class CDJGenerator(CueGenerator):
    """Pioneer CDJ-compatible CUE generator."""

    def __init__(self) -> None:
        """Initialize CDJ format generator."""
        super().__init__(CueFormat.CDJ)

    def _generate_disc_commands(self, disc: CueDisc) -> list[str]:
        """Generate CDJ-compatible disc commands.

        CDJ players have limited metadata support.
        """
        lines = []

        # CDJ mainly uses basic fields
        if disc.title:
            lines.append(f'TITLE "{disc.title}"')
        if disc.performer:
            lines.append(f'PERFORMER "{disc.performer}"')

        # Minimal REM support
        if genre := disc.rem_fields.get("GENRE"):
            lines.append(f'REM GENRE "{genre}"')
        if date := disc.rem_fields.get("DATE"):
            lines.append(f'REM DATE "{date}"')

        return lines


class TraktorGenerator(CueGenerator):
    """Native Instruments Traktor-compatible CUE generator."""

    def __init__(self) -> None:
        """Initialize Traktor format generator."""
        super().__init__(CueFormat.TRAKTOR)

    def _generate_track_commands(self, track: CueTrack) -> list[str]:
        """Generate Traktor-compatible track commands.

        Traktor uses REM fields for BPM and KEY information.
        """
        lines = super()._generate_track_commands(track)

        # Traktor-specific fields are already in REM fields
        # Just ensure proper formatting
        return lines


class SeratoGenerator(CueGenerator):
    """Serato DJ Pro-compatible CUE generator."""

    def __init__(self) -> None:
        """Initialize Serato format generator."""
        super().__init__(CueFormat.SERATO)

    def _generate_disc_commands(self, disc: CueDisc) -> list[str]:
        """Generate Serato-compatible disc commands.

        Serato has specific metadata requirements.
        """
        lines = []

        # Serato signature
        lines.append('REM COMMENT "Generated by Tracktion v1.0 (Serato-compatible)"')

        # Standard fields
        if disc.title:
            lines.append(f'TITLE "{disc.title}"')
        if disc.performer:
            lines.append(f'PERFORMER "{disc.performer}"')

        # Serato uses these REM fields
        for key in ["GENRE", "DATE", "DISCID"]:
            if value := disc.rem_fields.get(key):
                lines.append(f'REM {key} "{value}"')

        return lines


class RekordboxGenerator(CueGenerator):
    """Pioneer Rekordbox-compatible CUE generator."""

    def __init__(self) -> None:
        """Initialize Rekordbox format generator."""
        super().__init__(CueFormat.REKORDBOX)

    def _generate_track_commands(self, track: CueTrack) -> list[str]:
        """Generate Rekordbox-compatible track commands.

        Rekordbox supports extensive metadata.
        """
        lines = []

        # TRACK command
        lines.append(f"  TRACK {track.number:02d} AUDIO")

        # Standard metadata
        if track.title:
            title = track.title[:80] if len(track.title) > 80 else track.title
            lines.append(f'    TITLE "{title}"')
        if track.performer:
            performer = track.performer[:80] if len(track.performer) > 80 else track.performer
            lines.append(f'    PERFORMER "{performer}"')

        # Rekordbox-specific REM fields
        rekordbox_fields = ["BPM", "KEY", "GENRE", "LABEL", "YEAR", "COMMENT"]
        for key in rekordbox_fields:
            if value := track.rem_fields.get(key):
                lines.append(f'    REM {key} "{value}"')

        # INDEX commands
        for index_num in sorted(track.indices.keys()):
            time_ms = track.indices[index_num]
            time_str = self._format_time(time_ms)
            lines.append(f"    INDEX {index_num:02d} {time_str}")

        return lines


class KodiGenerator(CueGenerator):
    """Kodi media player-compatible CUE generator."""

    def __init__(self) -> None:
        """Initialize Kodi format generator."""
        super().__init__(CueFormat.KODI)

    def _generate_disc_commands(self, disc: CueDisc) -> list[str]:
        """Generate Kodi-compatible disc commands.

        Kodi supports multi-disc sets and extended metadata.
        """
        lines = []

        # Kodi uses DISCNUMBER for multi-disc support
        if not disc.rem_fields.get("DISCNUMBER"):
            disc.rem_fields["DISCNUMBER"] = "1"

        # CATALOG if present
        if disc.catalog:
            lines.append(f"CATALOG {disc.catalog}")

        # Extended REM fields for Kodi
        kodi_fields = [
            "DISCNUMBER",
            "TOTALDISCS",
            "GENRE",
            "DATE",
            "DISCID",
            "COMMENT",
            "ALBUMARTIST",
            "COMPILATION",
        ]

        for key in kodi_fields:
            if value := disc.rem_fields.get(key):
                # Always quote REM values for consistency
                lines.append(f'REM {key} "{value}"')

        # Add signature if not present
        if "COMMENT" not in disc.rem_fields:
            lines.append('REM COMMENT "Generated by Tracktion v1.0 (Kodi-compatible)"')

        # Standard fields
        if disc.title:
            lines.append(f'TITLE "{disc.title}"')
        if disc.performer:
            lines.append(f'PERFORMER "{disc.performer}"')

        return lines

    def _generate_track_commands(self, track: CueTrack) -> list[str]:
        """Generate Kodi-compatible track commands.

        Kodi supports ReplayGain and additional metadata.
        The ReplayGain fields (REPLAYGAIN_TRACK_GAIN, REPLAYGAIN_TRACK_PEAK,
        REPLAYGAIN_ALBUM_GAIN, REPLAYGAIN_ALBUM_PEAK) are handled through
        the track's rem_fields by the base implementation.
        """
        # The base implementation handles all rem_fields including ReplayGain
        return super()._generate_track_commands(track)


def get_generator(format_type: CueFormat) -> CueGenerator:
    """Factory function to get the appropriate generator for a format.

    Args:
        format_type: The desired CUE format.

    Returns:
        The appropriate CueGenerator subclass instance.
    """
    generators = {
        CueFormat.STANDARD: CueGenerator,
        CueFormat.CDJ: CDJGenerator,
        CueFormat.TRAKTOR: TraktorGenerator,
        CueFormat.SERATO: SeratoGenerator,
        CueFormat.REKORDBOX: RekordboxGenerator,
        CueFormat.KODI: KodiGenerator,
    }

    generator_class = generators.get(format_type, CueGenerator)
    if format_type == CueFormat.STANDARD or generator_class == CueGenerator:
        return CueGenerator(format_type)
    return generator_class()  # type: ignore[no-any-return]
