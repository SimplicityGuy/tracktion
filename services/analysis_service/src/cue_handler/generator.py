"""CUE file generator module for creating properly formatted CUE sheets."""

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any


class CueFormat(Enum):
    """Supported CUE format variants."""

    STANDARD = "standard"
    CDJ = "cdj"
    TRAKTOR = "traktor"
    SERATO = "serato"
    REKORDBOX = "rekordbox"
    KODI = "kodi"


@dataclass
class CueTrack:
    """Represents a single track in a CUE file."""

    number: int
    title: str
    performer: str
    start_time_ms: int
    songwriter: str | None = None
    isrc: str | None = None
    flags: list[str] = field(default_factory=list)
    rem_fields: dict[str, str] = field(default_factory=dict)
    pregap_ms: int | None = None
    postgap_ms: int | None = None
    indices: dict[int, int] = field(default_factory=dict)  # index_num -> time_ms

    def __post_init__(self) -> None:
        """Validate track data after initialization."""
        if self.number < 1 or self.number > 99:
            raise ValueError(f"Track number must be between 1-99, got {self.number}")
        if self.isrc and len(self.isrc) != 12:
            raise ValueError(f"ISRC must be 12 characters, got {len(self.isrc)}")

        # Validate FLAGS
        valid_flags = {"DCP", "4CH", "PRE", "SCMS"}
        for flag in self.flags:
            if flag not in valid_flags:
                raise ValueError(f"Invalid flag '{flag}', must be one of {valid_flags}")

        # Ensure INDEX 01 exists
        if 1 not in self.indices:
            self.indices[1] = self.start_time_ms


@dataclass
class CueDisc:
    """Represents disc-level metadata for a CUE file."""

    title: str | None = None
    performer: str | None = None
    catalog: str | None = None
    cdtextfile: str | None = None
    rem_fields: dict[str, str] = field(default_factory=dict)
    songwriter: str | None = None

    def __post_init__(self) -> None:
        """Validate disc data after initialization."""
        if self.catalog and len(self.catalog) != 13:
            raise ValueError(f"Catalog must be 13 digits, got {len(self.catalog)}")
        if self.title and len(self.title) > 80:
            self.title = self.title[:80]
        if self.performer and len(self.performer) > 80:
            self.performer = self.performer[:80]


@dataclass
class CueFile:
    """Represents a FILE entry in a CUE sheet."""

    filename: str
    file_type: str = "MP3"
    tracks: list[CueTrack] = field(default_factory=list)


class CueGenerator:
    """Generates CUE files in various formats from track data."""

    def __init__(self, format_type: CueFormat = CueFormat.STANDARD) -> None:
        """Initialize the CUE generator.

        Args:
            format_type: The CUE format variant to generate.
        """
        self.format_type = format_type

    def generate(
        self,
        disc: CueDisc,
        files: list[CueFile],
        output_path: Path | None = None,
    ) -> str:
        """Generate a CUE file from disc and track data.

        Args:
            disc: Disc-level metadata.
            files: List of FILE entries with tracks.
            output_path: Optional path to save the CUE file.

        Returns:
            The generated CUE content as a string.
        """
        lines = []

        # Generate disc-level commands
        lines.extend(self._generate_disc_commands(disc))

        # Generate file and track commands
        for cue_file in files:
            lines.extend(self._generate_file_commands(cue_file))

        cue_content = "\n".join(lines)

        # Save to file if path provided
        if output_path:
            output_path.write_text(cue_content, encoding="utf-8")

        return cue_content

    def _generate_disc_commands(self, disc: CueDisc) -> list[str]:
        """Generate disc-level CUE commands.

        Args:
            disc: Disc metadata.

        Returns:
            List of CUE command lines.
        """
        lines = []

        # Add format-specific REM fields first
        if self.format_type == CueFormat.KODI:
            disc.rem_fields.setdefault("DISCNUMBER", "1")

        # CATALOG must be first if present
        if disc.catalog:
            lines.append(f"CATALOG {disc.catalog}")

        # CDTEXTFILE second if present
        if disc.cdtextfile:
            lines.append(f'CDTEXTFILE "{disc.cdtextfile}"')

        # Add REM fields
        for key, value in disc.rem_fields.items():
            # Always quote REM values for consistency
            lines.append(f'REM {key} "{value}"')

        # Add signature comment
        if "COMMENT" not in disc.rem_fields:
            lines.append('REM COMMENT "Generated by Tracktion v1.0"')

        # Disc-level TITLE and PERFORMER
        if disc.title:
            lines.append(f'TITLE "{disc.title}"')
        if disc.performer:
            lines.append(f'PERFORMER "{disc.performer}"')
        if disc.songwriter:
            lines.append(f'SONGWRITER "{disc.songwriter}"')

        return lines

    def _generate_file_commands(self, cue_file: CueFile) -> list[str]:
        """Generate FILE and TRACK commands.

        Args:
            cue_file: File entry with tracks.

        Returns:
            List of CUE command lines.
        """
        lines = []

        # FILE command
        if " " in cue_file.filename:
            lines.append(f'FILE "{cue_file.filename}" {cue_file.file_type}')
        else:
            lines.append(f"FILE {cue_file.filename} {cue_file.file_type}")

        # Generate track commands
        for track in cue_file.tracks:
            lines.extend(self._generate_track_commands(track))

        return lines

    def _generate_track_commands(self, track: CueTrack) -> list[str]:
        """Generate commands for a single track.

        Args:
            track: Track data.

        Returns:
            List of CUE command lines.
        """
        lines = []

        # TRACK command
        lines.append(f"  TRACK {track.number:02d} AUDIO")

        # FLAGS if present
        if track.flags:
            lines.append(f"    FLAGS {' '.join(track.flags)}")

        # Track metadata
        if track.title:
            title = self._truncate_string(track.title, 80)
            lines.append(f'    TITLE "{title}"')
        if track.performer:
            performer = self._truncate_string(track.performer, 80)
            lines.append(f'    PERFORMER "{performer}"')
        if track.songwriter:
            lines.append(f'    SONGWRITER "{track.songwriter}"')
        if track.isrc:
            lines.append(f"    ISRC {track.isrc}")

        # Track-level REM fields
        for key, value in track.rem_fields.items():
            # Always quote REM values for consistency
            lines.append(f'    REM {key} "{value}"')

        # PREGAP if present
        if track.pregap_ms is not None:
            pregap_time = self._format_time(track.pregap_ms)
            lines.append(f"    PREGAP {pregap_time}")

        # INDEX commands
        for index_num in sorted(track.indices.keys()):
            time_ms = track.indices[index_num]
            time_str = self._format_time(time_ms)
            lines.append(f"    INDEX {index_num:02d} {time_str}")

        # POSTGAP if present
        if track.postgap_ms is not None:
            postgap_time = self._format_time(track.postgap_ms)
            lines.append(f"    POSTGAP {postgap_time}")

        return lines

    def _truncate_string(self, text: str, max_length: int) -> str:
        """Truncate a string to a maximum length.

        Args:
            text: The string to truncate.
            max_length: Maximum allowed length.

        Returns:
            Truncated string if longer than max_length, original otherwise.
        """
        return text[:max_length] if len(text) > max_length else text

    def _format_time(self, milliseconds: int) -> str:
        """Convert milliseconds to MM:SS:FF format.

        Args:
            milliseconds: Time in milliseconds.

        Returns:
            Time string in MM:SS:FF format (75 frames per second).
        """
        total_frames = (milliseconds * 75) // 1000
        minutes = total_frames // (75 * 60)
        remaining_frames = total_frames % (75 * 60)
        seconds = remaining_frames // 75
        frames = remaining_frames % 75
        return f"{minutes:02d}:{seconds:02d}:{frames:02d}"

    def from_tracklist(self, tracklist_data: dict[str, Any]) -> str:
        """Generate a CUE file from tracklist model data.

        Args:
            tracklist_data: Dictionary containing tracklist information.

        Returns:
            Generated CUE content.
        """
        # Extract disc metadata
        disc = CueDisc(
            title=tracklist_data.get("title", "Unknown Mix"),
            performer=tracklist_data.get("performer", "Unknown DJ"),
            rem_fields={
                "GENRE": tracklist_data.get("genre", "Electronic"),
                "DATE": str(tracklist_data.get("year", "2024")),
            },
        )

        # Add source information if available
        if source := tracklist_data.get("source"):
            disc.rem_fields["SOURCE"] = source

        # Create file entry with tracks
        tracks = []
        for idx, track_data in enumerate(tracklist_data.get("tracks", []), start=1):
            track = CueTrack(
                number=idx,
                title=track_data.get("title", f"Track {idx}"),
                performer=track_data.get("artist", "Unknown Artist"),
                start_time_ms=track_data.get("start_time", 0),
            )

            # Add any additional metadata
            if genre := track_data.get("genre"):
                track.rem_fields["GENRE"] = genre
            if bpm := track_data.get("bpm"):
                track.rem_fields["BPM"] = str(bpm)

            tracks.append(track)

        # Create single file entry (assuming single mix file)
        filename = tracklist_data.get("filename", "mix.mp3")
        cue_file = CueFile(
            filename=filename,
            file_type=self._determine_file_type(filename),
            tracks=tracks,
        )

        return self.generate(disc, [cue_file])

    def _determine_file_type(self, filename: str) -> str:
        """Determine CUE file type from filename extension.

        Args:
            filename: The audio filename.

        Returns:
            CUE file type (MP3, WAVE, etc.).
        """
        ext = Path(filename).suffix.lower()
        type_map = {
            ".mp3": "MP3",
            ".wav": "WAVE",
            ".flac": "FLAC",
            ".aiff": "AIFF",
            ".m4a": "MP4",
        }
        return type_map.get(ext, "BINARY")
